"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8341],{3641:(s,e,i)=>{i.r(e),i.d(e,{comp:()=>n,data:()=>p});var a=i(641);const t={},n=(0,i(6262).A)(t,[["render",function(s,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h1 id="说说对-node-中的-process-的理解-有哪些常用方法" tabindex="-1"><a class="header-anchor" href="#说说对-node-中的-process-的理解-有哪些常用方法"><span>说说对 Node 中的 process 的理解？有哪些常用方法？</span></a></h1><figure><img src="https://static.vue-js.com/4f7866b0-c2b2-11eb-85f6-6fac77c0c9b3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="一、是什么" tabindex="-1"><a class="header-anchor" href="#一、是什么"><span>一、是什么</span></a></h2><p><code>process</code> 对象是一个全局变量，提供了有关当前 <code>Node.js </code>进程的信息并对其进行控制，作为一个全局变量</p><p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p><p>当我们启动一个<code>js</code>文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享</p><p>由于<code>JavaScript</code>是一个单线程语言，所以通过<code>node xxx</code>启动一个文件后，只有一条主线程</p><h2 id="二、属性与方法" tabindex="-1"><a class="header-anchor" href="#二、属性与方法"><span>二、属性与方法</span></a></h2><p>关于<code>process</code>常见的属性有如下：</p><ul><li>process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息</li><li>process.nextTick：这个在谈及 <code>EventLoop</code> 时经常为会提到</li><li>process.pid：获取当前进程id</li><li>process.ppid：当前进程对应的父进程</li><li>process.cwd()：获取当前进程工作目录，</li><li>process.platform：获取当前进程运行的操作系统平台</li><li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li><li>进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li><li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li><li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li></ul><p>下面再稍微介绍下某些方法的使用：</p><h3 id="process-cwd" tabindex="-1"><a class="header-anchor" href="#process-cwd"><span>process.cwd()</span></a></h3><p>返回当前 <code>Node </code>进程执行的目录</p><p>一个<code> Node</code> 模块 <code>A</code> 通过 NPM 发布，项目 <code>B</code> 中使用了模块 <code>A</code>。在 <code>A</code> 中需要操作 <code>B</code> 项目下的文件时，就可以用 <code>process.cwd()</code> 来获取 <code>B</code> 项目的路径</p><h3 id="process-argv" tabindex="-1"><a class="header-anchor" href="#process-argv"><span>process.argv</span></a></h3><p>在终端通过 Node 执行命令的时候，通过 <code>process.argv</code> 可以获取传入的命令行参数，返回值是一个数组：</p><ul><li>0: Node 路径（一般用不到，直接忽略）</li><li>1: 被执行的 JS 文件路径（一般用不到，直接忽略）</li><li>2~n: 真实传入命令的参数</li></ul><p>所以，我们只要从 <code>process.argv[2]</code> 开始获取就好了</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> args</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> process</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">argv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">slice</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="process-env" tabindex="-1"><a class="header-anchor" href="#process-env"><span>process.env</span></a></h3><p>返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。</p><p>一般我们会在 <code>process.env</code> 上挂载一些变量标识当前的环境。比如最常见的用 <code>process.env.NODE_ENV</code> 区分 <code>development</code> 和 <code>production</code></p><p>在 <code>vue-cli</code> 的源码中也经常会看到 <code>process.env.VUE_CLI_DEBUG</code> 标识当前是不是 <code>DEBUG</code> 模式</p><h3 id="process-nexttick" tabindex="-1"><a class="header-anchor" href="#process-nexttick"><span>process.nextTick()</span></a></h3><p>我们知道<code>NodeJs</code>是基于事件轮询，在这个过程中，同一时间只会处理一件事情</p><p>在这种处理模式下，<code>process.nextTick()</code>就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行</p><p>例如下面例子将一个<code>foo</code>函数在下一个时间点调用</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;foo&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">process</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">nextTick</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;bar&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为<code>bar</code>、<code>foo</code></p><p>虽然下述方式也能实现同样效果：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;bar&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>两者区别在于：</p><ul><li>process.nextTick()会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback</li><li>setTimeout()是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的</li></ul><h3 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h3><ul><li><a href="http://nodejs.cn/api/process.html" target="_blank" rel="noopener noreferrer">http://nodejs.cn/api/process.html</a></li><li><a href="https://vue3js.cn/interview/" target="_blank" rel="noopener noreferrer">https://vue3js.cn/interview/</a></li></ul>',35)]))}]]),p=JSON.parse('{"path":"/posts/NodeJS/process.html","title":"说说对 Node 中的 process 的理解？有哪些常用方法？","lang":"zh-CN","frontmatter":{"date":"2025-05-22T00:00:00.000Z","category":"-NodeJS系列","tag":["面试题"],"description":"说说对 Node 中的 process 的理解？有哪些常用方法？ 一、是什么 process 对象是一个全局变量，提供了有关当前 Node.js 进程的信息并对其进行控制，作为一个全局变量 我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器 当我们启动一个js文件，实际就是开启了一个服务进程，每个进程都拥有自己的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"说说对 Node 中的 process 的理解？有哪些常用方法？\\",\\"image\\":[\\"https://static.vue-js.com/4f7866b0-c2b2-11eb-85f6-6fac77c0c9b3.png\\"],\\"datePublished\\":\\"2025-05-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-23T11:03:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"一次元\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/NodeJS/process.html"}],["meta",{"property":"og:site_name","content":"一次元"}],["meta",{"property":"og:title","content":"说说对 Node 中的 process 的理解？有哪些常用方法？"}],["meta",{"property":"og:description","content":"说说对 Node 中的 process 的理解？有哪些常用方法？ 一、是什么 process 对象是一个全局变量，提供了有关当前 Node.js 进程的信息并对其进行控制，作为一个全局变量 我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器 当我们启动一个js文件，实际就是开启了一个服务进程，每个进程都拥有自己的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://static.vue-js.com/4f7866b0-c2b2-11eb-85f6-6fac77c0c9b3.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-23T11:03:34.000Z"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:published_time","content":"2025-05-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-23T11:03:34.000Z"}]]},"git":{"createdTime":1747998214000,"updatedTime":1747998214000,"contributors":[{"name":"shenyuan","username":"shenyuan","email":"13618329369@163.com","commits":1,"url":"https://github.com/shenyuan"}]},"readingTime":{"minutes":2.93,"words":879},"filePathRelative":"posts/NodeJS/process.md","excerpt":"\\n<figure><img src=\\"https://static.vue-js.com/4f7866b0-c2b2-11eb-85f6-6fac77c0c9b3.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<h2>一、是什么</h2>\\n<p><code>process</code> 对象是一个全局变量，提供了有关当前 <code>Node.js </code>进程的信息并对其进行控制，作为一个全局变量</p>\\n<p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p>","autoDesc":true}')},6262:(s,e)=>{e.A=(s,e)=>{const i=s.__vccOpts||s;for(const[s,a]of e)i[s]=a;return i}}}]);